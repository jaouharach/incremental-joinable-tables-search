\section{Proposed Approach}
\label{sec:system-architecture}

\iffalse
\small
\begin{algorithm}
	\DontPrintSemicolon
	\caption{{\sc BuildIndex}}
	\label{algo:build_index}
\end{algorithm}

\small
\fi



% COORDINATOR ALGORITHM

\small
\begin{algorithm}
	\DontPrintSemicolon % Some LaTeX compilers require you to use \dontprintsemicolon instead
	\KwIn{$JobArray = \{q_{1}, ..., q_{n}\}$, $k$, $r_{th}$, $m$ the number of threads, $JobCounter$, $AllWorkersDone$.}
	\KwOut{$KnnResults$.}
	
	\vspace{.2cm}
	\textbf{Thread Array} $Workers[m]$;\\
	\textbf{Boolean Array} $WorkersState[m] \gets \{False, ..., False\}$;\\
	\textbf{Integer} $NumWorkingThreads$ = m;\\
	\textbf{Barrier Array} $Barrier[m]$; \\
	\textbf{Boolean} $WorkerDone \gets True$;\\
	\textbf{Shared Queue} $KnnResults[n][k] \gets \{\{+\infty_{1}, ..., +\infty_{k}\}_{q_{1}}, ..., \{+\infty_{1}, ..., +\infty_{k}\}_{q_{n}}\}$;\\
	\vspace{.2cm}
	
	\For{$i \gets 0$ \KwTo $m - 1$}
	{
		$Workers[i].${\sc InitWorkerThread}$(JobArray, k, $\\ $JobCounter, Barrier[i], KnnResults, WorkersState[i], NumWorkingThreads)$;\\
	}
	
	\tcp{get incremental results}
	\While{True}
	{
		\For{$i \gets 0$ \KwTo $m - 1$}
		{
			\If{!$AtomicCompare(WorkersState[i], WorkerDone)$}
			{
				{\it Coordinator waits on} $Barrier[i];$\\
			}
			
		}

		%\If{\it Recall($KnnResults$, GroundThruth) $\geq r_{th}$)}
		%{
		%	$StopAllWorkers()$;\\
		%	Return {KnnResults};
		%}
		\If{!$AtomicCompare(NumWorkingThreads, 0)$}
		{
			\tcp{no more jobs and all workers finished their jobs.}
			break;\\
		}
	
	}
	
	\caption{{\sc Kashif: StartThreadPool}}
	\label{algo:coordinator}
\end{algorithm}

% END COORDINATOR ALGORITHM


\begin{algorithm}
	\DontPrintSemicolon
	\KwIn{A query vector $q$, $k$, $N_{root}$.}
	\KwOut{$k$ Nearest Vectors to $q$.}
	\vspace{.2cm}
	\textbf{Queue} $Knn[k] \gets \{(null, \infty_{1}), ..., (null, \infty_{k})\}$;\\
	\textbf{Node} $N \gets N_{root}$;\\
	\While{!$N.IsLeaf()$}
	{
		$SP = N.SplitPolicy()$;\\
		$N = N.RouteToChildNode(q, SP)$;\\
		
	}
	\vspace{.1cm}
	$(v', bsf) = Knn[k]$;\\
	\ForEach{$v \in N.Vcetors()$}
	{
		\If{$D(v, q) \leq bsf $}
		{
			$Knn.SortedInsert(v, D(v, q))$;\\
		}
		$(v', bsf) = Knn[k]$;\\
	}


	\KwRet{$Knn$;}
	\caption{{\sc HeuristicKnnSearch}}
	\label{algo:heuristic_knn_search}
\end{algorithm}



% INITIALIZE WORKER THREAD
\small
\begin{algorithm}
	\DontPrintSemicolon % Some LaTeX compilers require you to use \dontprintsemicolon instead
	\KwIn{$JobArray$, $k$,  $JobCounter$, $Barrier$, $KnnResults$, $WorkerState$, $NumWorkingThreads$.}
	\vspace{.2cm}
	
	\While{True}
	{
		$JobIdx = SyncFetchAndAdd(JobCounter)$;\\
		\If{$JobIdx > JobArray.Size()$} 
		{
			$SyncFetchAndSub(NumWorkingThreads)$;\\
			$break$; \tcp{no more jobs to do}\\
		}
		$q = JobArray[JobIdx]$;\\
	 	{\sc ExactKnnSearch$(q, k, KnnResults[JobIdx], Barrier, WorkerState)$};
	 	
	}
	
	\caption{{\sc Kashif: InitWorkerThread}}
	\label{algo:init_thread}
\end{algorithm}
% END INITIALIZE WORKER THREAD


% KNN SEARCH (ONE THREAD)
\small
\begin{algorithm}
	\DontPrintSemicolon
	\KwIn{A query vectors $q$,  $k$, knnResults, Barrier, $N_{root}$.}
	\vspace{.2cm}
	
	\tcp{local knn results, ordered by distance}
	\textbf{Queue} $Knn[k] \gets \{(null, +\infty_{1}), ..., (null, +\infty_{k})\}$;\\
	\textbf{Queue} $pq  \gets \{\}$; \tcp{priority queue}
	\tcc{last NN returned by incremental search is at position LastIncrResult - 1}
	\textbf{Integer} $LastIncrResult \gets 0$; \\
	\textbf{Integer} $UpdateStart \gets 0$; \tcp{where new results start}
	\textbf{Integer} $UpdateEnd \gets 0$; \tcp{where new results end}
	\textbf{Boolean} $NewIncrement \gets False$;
	\vspace{.2cm}
	
	$AtomicSet(WorkerState, False)$;\\ \tcp{thread is working}
	
	\tcc{perform heuristic search and update knn results in global array}
	$KnnResults \gets ${\sc HeuristicKnnSearch$(q, k)$};\\

	\tcp{initialize priority queues}
	$pq.Add(N_{root}$);\\
	\vspace{.2cm}
	
	\While{!pq.Empty()}
	{
		NewIncrement = False;\\
		\While{!NewIncrement and !pq.Empty()}
		{
			$N \gets pq.Pop()$;\\
			
			\For{$pos \gets LastIncrResult$ \KwTo $k - 1$}
			{
				$(v', bsf) \gets Knn[pos]$;\\
				\If{$D_{lb}(N, q) > bsf$}
				{
					$LastIncrResult \gets pos + 1$;\\
					$NewIncrement \gets True$;\\
				}
			}
			\If{NewIncrement}
			{
				$UpdateStart \gets UpdateEnd$;\\
				$UpdateEnd \gets LastIncrResult$;\\ 
			}
		
			\If{$N.IsLeaf()$}
			{
				$(v', bsf) \gets Knn[k]$;\\
				\ForEach{$v \in N.Vcetors()$}
				{
					\If{$D(v, q) < bsf $}
					{
						$Knn.SortedInsert(v, D(v, q))$;\\
					}
				}
			}
			\Else
			{
				\ForEach {$N'$ in $N.ChildNodes()$}
				{
					\If {$D_{lb}(N', q) < bsf$}
					{
						$pq.Add(N')$;\\	
					}	
				}
			}
		}
	
		\tcp{copy new results to global kNN Queue}
		$CopyResults(Knn, KnnReasults, UpdateStart, UpdateEnd)$;\\
		 \tcp{Wait for other threads to finish current increment}
		 {\it Thread} blocks on $Barrier$;
		 $AtomicSet(WorkerState, True)$;\\ \tcp{thread stoped working}
	}
	\caption{{\sc ExactKnnSearch}}
	\label{algo:exact_knn_search}
\end{algorithm}

%END KNN SEARCH (ONE THREAD)